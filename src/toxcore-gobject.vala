/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* tox-session.c
 * tox-session.vala
 * This file is part of Venom
 * Copyright (C) 2015 Venom authors
 * Venom is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Venom is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
using ToxAPI;

namespace Tox{
 	/**
	 * The major version number. Incremented when the API or ABI changes in an
	 * incompatible way.
	 */
	public const uint32 MAJOR = ToxAPI.Version.MAJOR;
			/**
	 * The minor version number. Incremented when functionality is added without
	 * breaking the API or ABI. Set to 0 when the major version number is
	 * incremented.
	 */
	public const uint32 MINOR = ToxAPI.Version.MINOR;
	/**
	 * The patch or revision number. Incremented when bugfixes are applied without
	 * changing any functionality or API or ABI.
	 */
	public const uint32 PATCH = ToxAPI.Version.PATCH;

	/**
	 * A macro to check at preprocessing time whether the client code is compatible
	 * with the installed version of Tox.
	 */
	
	public static bool is_api_compatible(uint32 major, uint32 minor, uint32 patch){
		return ToxAPI.Version.is_api_compatible(major,minor,patch);
	}
	/**
	 * A macro to make compilation fail if the client code is not compatible with
	 * the installed version of Tox.
	 */
	public static char require_version(uint32 major, uint32 minor, uint32 patch){
		return ToxAPI.Version.require_version(major, minor, patch);
	}

	/**	
	 * Return the major version number of the library. Can be used to display the
	 * Tox library version or to check whether the client is compatible with the
	 * dynamically linked version of Tox.
	 */	
	
	public static uint32 library_major(){
		return ToxAPI.Version.library_major();
	}

	/**
	 * Return the minor version number of the library.
	 */
	
	public static uint32 library_minor(){
		return ToxAPI.Version.library_minor();
	}
	
	/**
	 * Return the patch number of the library.
	 */
	public static uint32 library_patch(){
		return ToxAPI.Version.library_patch();
	}
	/**
	 * Return whether the compiled library version is compatible with the passed
	 * version numbers.
	 */

	public static bool is_compatible(uint32 major, uint32 minor, uint32 patch){
		return ToxAPI.Version.is_compatible(major,minor,patch);
	}
	/**
	 * A convenience macro to call ToxAPI.TOX_version_is_compatible with the currently
	 * compiling API version.
	 */
	public static bool is_abi_compatible(){
		return ToxAPI.Version.is_abi_compatible();
	}
	
	

	/**
	 * The size of a Tox Public Key in bytes.
	 */
	public const int PUBLIC_KEY_SIZE = ToxAPI.PUBLIC_KEY_SIZE;

	/**
	 * The size of a Tox Secret Key in bytes.
	 */
	public const int SECRET_KEY_SIZE = ToxAPI.SECRET_KEY_SIZE;

	/**
	 * The size of a Tox address in bytes. Tox addresses are in the format
	 * [Public Key (ToxAPI.TOX_PUBLIC_KEY_SIZE bytes)][nospam (4 bytes)][checksum (2 bytes)].
	 *
	 * The checksum is computed over the Public Key and the nospam value. The first
	 * byte is an XOR of all the even bytes (0, 2, 4, ...), the second byte is an
	 * XOR of all the odd bytes (1, 3, 5, ...) of the Public Key and nospam.
	 */
	public const int ADDRESS_SIZE = ToxAPI.ADDRESS_SIZE;
	/**
	 * Maximum length of a nickname in bytes.
	 */
	public const int MAX_NAME_LENGTH = ToxAPI.MAX_NAME_LENGTH;
  
	/**
	 * Maximum length of a status message in bytes.
	 */
	public const int MAX_STATUS_MESSAGE_LENGTH = ToxAPI.MAX_STATUS_MESSAGE_LENGTH;

	/**
	 * Maximum length of a friend request message in bytes.
	 */
	public const int MAX_FRIEND_REQUEST_LENGTH = ToxAPI.MAX_FRIEND_REQUEST_LENGTH;
	
	/**
	 * Maximum length of a single message after which it should be split.
	 */
	public const int MAX_MESSAGE_LENGTH = ToxAPI.MAX_MESSAGE_LENGTH;
	/**
	 * Maximum size of custom packets. TODO: should be LENGTH?
	 */
	public const int MAX_CUSTOM_PACKET_SIZE = ToxAPI.MAX_CUSTOM_PACKET_SIZE;

	/**
	 * The number of bytes in a hash generated by ToxAPI.TOX_hash.
	 */
	public const int HASH_LENGTH = ToxAPI.HASH_LENGTH;
	/**
	 * The number of bytes in a file id.
	 */
	public const int FILE_ID_LENGTH = ToxAPI.FILE_ID_LENGTH;

	/**
	 * Maximum file name length for file transfers.
	 */
	public const int MAX_FILENAME_LENGTH = ToxAPI.MAX_FILENAME_LENGTH;
	
	public enum UserStatus : ToxAPI.UserStatus{}
	
	public enum ConnectionStatus: ToxAPI.ConnectionStatus{}
	
	public enum FileControlStatus: ToxAPI.FileControlStatus{}
	
	public enum FileKind : ToxAPI.FileKind{}
	
	public enum MessageType : ToxAPI.MessageType {}
	
	public enum ProxyType : ToxAPI.ProxyType {}
	
	public enum SavedataType : ToxAPI.SavedataType{}
	
	public errordomain ConstructError{
		/**
		 * The function was unable to bind to a port. This may mean that all ports
		 * have already been bound, e.g. by other Tox instances, or it may mean
		 * a permission error. You may be able to gather more information from errno.
		 */
		BAD_PORT_ALLOC,

		/**
		 * proxy_type was valid but the proxy_host passed had an invalid format
		 * or was NULL.
		 */
		BAD_HOST,

		/**
		 * proxy_type was valid, but the proxy_port was invalid.
		 */
		PORT_UNAVAILABLE,

		/**
		 * The proxy address passed could not be resolved.
		 */
		PROXY_NOT_FOUND,

		/**
		 * The byte array to be loaded contained an encrypted save.
		 */
		ENCRYPTED_DATA,

		/**
		 * The data format was invalid. This can happen when loading data that was
		 * saved by an older version of Tox, or when the data has been corrupted.
		 * When loading from badly formatted data, some data may have been loaded,
		 * and the rest is discarded. Passing an invalid length parameter also
		 * causes this error.
		 */
		MALFORMED_DATA,

		UNKNOWN,
	}

	public errordomain BootstrapError{
		BAD_HOST,
		BAD_PORT,
	}
		
	public errordomain FriendAddError {
		TOOLONG,
		NO_MESSAGE,
		OWN_KEY,
		ALREADY_SENT,
		UNKNOWN,
		BAD_CHECKSUM,
		SET_NEW_NOSPAM,
		NOMEM,
	}		
	
	public errordomain FriendGetError{
		NOT_FOUND,
		UNKNOWN,		
	}
		
	public errordomain SendMessageError{
	
		/**
		 * The friend number did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,

		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,

		/**
		 * An allocation error occurred while increasing the send queue size.
		 */
		SENDQ,


	}
	
	public errordomain FileControlError{
		/**
		 * The friend_number passed did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,
		
		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,
		
		/**
		 * No file transfer with the given file number was found for the given friend.
		 */
		NOT_FOUND,
		
		/**
		 * A RESUME control was sent, but the file transfer is running normally.
		 */
		NOT_PAUSED,
	
		/**
		 * A RESUME control was sent, but the file transfer was paused by the other
		 * party. Only the party that paused the transfer can resume it.
		 */
		DENIED,
		
		/**
		 * A PAUSE control was sent, but the file transfer was already paused.
		 */
		ALREADY_PAUSED,
		
		/**
		 * Packet queue is full.
		 */
		SENDQ,
	
	}
	
	public errordomain FileSeekError {
		
		/**
		 * The friend_number passed did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,
		
		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,
		
		/**
		 * No file transfer with the given file number was found for the given friend.
		 */
		NOT_FOUND,
		
		/**
		 * File was not in a state where it could be seeked.
		 */
		DENIED,
		
		/**
		 * Seek position was invalid
		 */
		INVALID_POSITION,
		
		/**
		 * Packet queue is full.
		 */
		SENDQ,

	}
	
	public errordomain FileGetError{
		/**
	     * The friend_number passed did not designate a valid friend.
	     */
	    FRIEND_NOT_FOUND,

	    /**
	     * No file transfer with the given file number was found for the given friend.
	     */
    	NOT_FOUND,
	
	}
	
	public errordomain FileSendError{
		FRIEND_NOT_FOUND,
		FRIEND_NOT_CONNECTED,
		TOO_MANY,
	}
	
	public errordomain FileSendChunkError{
		FRIEND_NOT_FOUND,
		FRIEND_NOT_CONNECTED,
		NOT_FOUND,
		NOT_TRANSFERRING,
		INVALID_LENGTH,
		SENDQ,
		WRONG_POSITION,
	}
  	
  	public errordomain CustomPacketError{
  		/**
		 * The friend number did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,
		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,
		/**
		 * The first byte of data was not in the specified range for the packet type.
		 * This range is 200-254 for lossy, and 160-191 for lossless packets.
		 */
		INVALID,
		/**
		 * Packet data length exceeded MAX_CUSTOM_PACKET_SIZE.
		 */
		TOO_LONG,
		/**
		 * Packet queue is full.
		 */
		SENDQ,
  	
  	}
	
	
	public class Options: ToxAPI.Options{
 		public Options(){
			ToxAPI.TOX_ERR_OPTIONS_NEW en;
			Options ret = (Options)ToxAPI.Options.options_new(out en);
			return ret;
		}
	}
	
	public class Core : Object{
		private ToxAPI.ToxRaw? internal_handle;
		
		public uint32 nospam {
			get{ return internal_handle.nospam;} 
			set{ internal_handle.nospam = value;}
		}
		
		public UserStatus status{
			get{ return internal_handle.status;}
			set{ internal_handle.status = (UserStatus) value;}
		}
		
		public string status_message{
			get{ return  internal_handle.get_status_message().to_string();}
			set{
				if (value.data.length <= MAX_STATUS_MESSAGE_LENGTH){
					internal_handle.set_status_message(value);
				}
			}
		}
		
		public string name{
			get{ return internal_handle.get_name().to_string();}
			set{
				if (value.data.length <= MAX_NAME_LENGTH){
					internal_handle.set_name(value);
				}
			}
		}
		
		public owned uint8[] address{
			owned get{ return internal_handle.get_address(); }
		}
		
		public owned uint8[] public_key{
			owned get{ return internal_handle.get_public_key(); }
		}
		
		public owned uint8[] secret_key{
			owned get { return internal_handle.get_secret_key}
		}
		
		public ConnectionStatus connection_status{
			get{ return internal_handle.get_connection_status(); }
		}
		
		public uint32 iteration_interval{
			get{ return internal_handle.iteration_interval();}
		}


		public Core(Options? options = null ) throws ConstructError{
			ToxAPI.TOX_ERR_NEW err;
			internal_handle = ToxAPI.ToxRaw.create(options, out err);
			switch(err){
				case ToxAPI.TOX_ERR_NEW.NULL:
					throw new ConstructError.UNKNOWN("A parameter was null");
					break;
				case ToxAPI.TOX_ERR_NEW.MALLOC:
					throw new ConstructError.UNKNOWN("Unable to allocate memory for the Tox instance");
					break;
				case ToxAPI.TOX_ERR_NEW.PORT_ALLOC:
					throw new ConstructError.BAD_PORT_ALLOC( err.to_string() + ": Unable to seize the received port");
					break;
				case ToxAPI.TOX_ERR_NEW.PROXY_BAD_HOST:
					throw new ConstructError.BAD_HOST("Invalid host (host was" + (options.proxy_host ?? "null") + ")");
					break;
				case ToxAPI.TOX_ERR_NEW.PROXY_BAD_PORT:
					throw new ConstructError.PORT_UNAVAILABLE("Port not available (" + options.proxy_port.to_string() + ")");
					break;
				case ToxAPI.TOX_ERR_NEW.PROXY_NOT_FOUND:
					throw new ConstructError.PROXY_NOT_FOUND("Unable to connect to the proxy (TYPE_" + options.proxy_type.to_string() + " : " + options.proxy_host ?? "null" + ")");
					break;
				case ToxAPI.TOX_ERR_NEW.LOAD_ENCRYPTED:
					throw new ConstructError.ENCRYPTED_DATA("Data was unexpectedly encrypted or looks encrypted");
					break;
				case ToxAPI.TOX_ERR_NEW.LOAD_BAD_FORMAT:
					throw new ConstructError.MALFORMED_DATA("Data was not properly formatted");
					break;
				default:
					break;
			}
			 this.connection_status_callback((raw, status)=>{this.notify_property("connection_status")});
		}
		
		public uint8[] get_savedata(){
			return internal_handle.get_savedata();
		}
		

		/**
		 * Sends a "get nodes" request to the given bootstrap node with IP, port, and
		 * public key to setup connections.
		 *
		 * This function will attempt to connect to the node using UDP. You must use
		 * this function even if Tox_Options.udp_enabled was set to false.
		 *
		 * @param address The hostname or IP address (IPv4 or IPv6) of the node.
		 * @param port The port on the host on which the bootstrap Tox instance is
		 *   listening.
		 * @param public_key The long term public key of the bootstrap node
		 * @throws BootstrapError.
		 */
		public void bootstrap(string address, uint16 port, uint8[] public_key) throws BootstrapError{
			ToxAPI.TOX_ERR_BOOTSTRAP err;
			bool res = internal_handle.connect (address, port, public_key, out err);
			if(!res){
				switch(err){
					case TOX_ERR_BOOTSTRAP.BAD_HOST:
						throw new BootstrapError.BAD_HOST("Host " + address.to_string()+ " is invalid");
						break;
					case TOX_ERR_BOOTSTRAP.BAD_PORT:
						throw new BootstrapError.BAD_PORT("Port "+ port.to_string()+ " not valid or unavailable");
					default:
						throw new BootstrapError.BAD_HOST("Unable to connect, please check bootstrap parameters");
				}	
			}
		}
		

		/**
		 * Adds additional host:port pair as TCP relay.
		 *
		 * This function can be used to initiate TCP connections to different ports on
		 * the same bootstrap node, or to add TCP relays without using them as
		 * bootstrap nodes.
		 *
		 * @param address The hostname or IP address (IPv4 or IPv6) of the TCP relay.
		 * @param port The port on the host on which the TCP relay is listening.
		 * @param public_key The long term public key of the TCP relay
		 * @throws BootstrapError
		 */
		public void add_tcp_relay(string address, uint16 port, uint8[] public_key) throws BootstrapError requires(public_key.length == PUBLIC_KEY_SIZE)  {
			ToxAPI.TOX_ERR_BOOTSTRAP err = ToxAPI.TOX_ERR_BOOTSTRAP.INVALID_ENUM;
			bool res = internal_handle.add_tcp_relay (address, port, public_key, out err);
			if(!res){
				switch(err){
					case TOX_ERR_BOOTSTRAP.BAD_HOST:
						throw new BootstrapError.BAD_HOST("Relay Host " + address.to_string()+ " is invalid");
						break;
					case TOX_ERR_BOOTSTRAP.BAD_PORT:
						throw new BootstrapError.BAD_PORT( "Port "+ port.to_string()+ " not valid or unavailable");
						break;
					default:
						break;
				}	
			}	
		}
		
		public void iterate(){
			internal_handle.iterate();
		}

		/**
		 * Add a friend to the friend list and send a friend request.
		 *
		 * A friend request message must be at least 1 byte long and at most
		 * MAX_FRIEND_REQUEST_LENGTH.
		 *
		 * Friend numbers are unique identifiers used in all functions that operate on
		 * friends. Once added, a friend number is stable for the lifetime of the Tox
		 * object. After saving the state and reloading it, the friend numbers may not
		 * be the same as before. Deleting a friend creates a gap in the friend number
		 * set, which is filled by the next adding of a friend. Any pattern in friend
		 * numbers should not be relied on.
		 *
		 * If more than uint32.MAX friends are added, this function causes undefined
		 * behaviour.
		 *
		 * @param address The address of the friend (returned by tox_self_get_address of
		 *   the friend you wish to add) it must be ADDRESS_SIZE bytes.
		 * @param message The message that will be sent along with the friend request.
		 *
		 * @return the friend number on success, uint32.MAX on failure.
		 */
		public uint32 add_friend(uint8[] address, string message) throws FriendAddError
									requires(message.data.length <= MAX_FRIEND_REQUEST_LENGTH)
									requires(message.data.length >0)
									requires(address.length == ADDRESS_SIZE){
			ToxAPI.TOX_ERR_FRIEND_ADD err = ToxAPI.TOX_ERR_FRIEND_ADD.INVALID_ENUM;
			uint32 num = internal_handle.friend_add(address, message.data, out err);
			switch(err){
				case TOX_ERR_FRIEND_ADD.OWN_KEY:
					throw new FriendAddError.OWN_KEY("The provided key is the same client key");
					break;
				case TOX_ERR_FRIEND_ADD.ALREADY_SENT:
					throw new FriendAddError.ALREADY_SENT("The provided key belongs to an already addede friend");
					break;
				case TOX_ERR_FRIEND_ADD.BAD_CHECKSUM:
					throw new FriendAddError.BAD_CHECKSUM("Checksum was invalid");
					break;
				case TOX_ERR_FRIEND_ADD.SET_NEW_NOSPAM:
					throw new FriendAddError.SET_NEW_NOSPAM("Client was already added, changed the nospam value");
					break;
				case TOX_ERR_FRIEND_ADD.MALLOC:
					throw new FriendAddError.NOMEM("Error allocating the friend request");
					break;
				default:
					break;
			}
			return num;
		}


		/**
		 * Add a friend without sending a friend request.
		 *
		 * This function is used to add a friend in response to a friend request. If the
		 * client receives a friend request, it can be reasonably sure that the other
		 * client added this client as a friend, eliminating the need for a friend
		 * request.
		 *
		 * This function is also useful in a situation where both instances are
		 * controlled by the same entity, so that this entity can perform the mutual
		 * friend adding. In this case, there is no need for a friend request, either.
		 *
		 * @param public_key A byte array of length PUBLIC_KEY_SIZE containing the
		 *   Public Key (not the Address) of the friend to add.
		 *
		 * @return the friend number on success, uint32.MAX on failure.
		 * @see tox_friend_add for a more detailed description of friend numbers.
		 */
		public uint32 add_friend_norequest( uint8[] public_key) throws FriendAddError{
			ToxAPI.TOX_ERR_FRIEND_ADD err = ToxAPI.TOX_ERR_FRIEND_ADD.INVALID_ENUM;
			uint32 num = internal_handle.friend_add_norequest(public_key, out err);
			switch(err){
				case TOX_ERR_FRIEND_ADD.OWN_KEY:
					throw new FriendAddError.OWN_KEY("The provided key is the same client key");
					break;
				case TOX_ERR_FRIEND_ADD.ALREADY_SENT:
					throw new FriendAddError.ALREADY_SENT("The provided key belongs to an already addede friend");
					break;
				case TOX_ERR_FRIEND_ADD.BAD_CHECKSUM:
					throw new FriendAddError.BAD_CHECKSUM("Checksum was invalid");
					break;
				case TOX_ERR_FRIEND_ADD.SET_NEW_NOSPAM:
					throw new FriendAddError.SET_NEW_NOSPAM("Client was already added, changed the nospam value");
					break;
				case TOX_ERR_FRIEND_ADD.MALLOC:
					throw new FriendAddError.NOMEM("Error allocating the friend request");
				default:
					break;
			}
			return num;
		}


		/**
		 * Remove a friend from the friend list.
		 *
		 * This does not notify the friend of their deletion. After calling this
		 * function, this client will appear offline to the friend and no communication
		 * can occur between the two.
		 *
		 * @param friend_number Friend number for the friend to be deleted.
		 *
		 * @return true on success.
		 */
		public bool delete_friend(uint32 friend_number){
			ToxAPI.TOX_ERR_FRIEND_DELETE err;
			return internal_handle.friend_delete(friend_number, out err);
		}
		



		/**
		 * Return the friend number associated with that Public Key.
		 *
		 * @return the friend number on success, uint32.MAX on failure.
		 * @param public_key A byte array containing the Public Key.
		 * @throws FriendGetError
		 */
		public uint32 get_friend_by_public_key( uint8[] public_key) throws FriendGetError{
			ToxAPI.TOX_ERR_FRIEND_BY_PUBLIC_KEY err;
			uint32 retval = internal_handle.friend_by_public_key(public_key, out err);
			switch (err){
				case TOX_ERR_FRIEND_BY_PUBLIC_KEY.NOT_FOUND:
				 	throw new FriendGetError.NOT_FOUND("The provided pubkey does not belong to a friend");
				 default:
				 	break;
			}
			return retval;
		}
		
		/**
		 * Checks if a friend with the given friend number exists and returns true if
		 * it does.
		 */
		public bool friend_exists(uint32 friend_number){
			return internal_handle.friend_exists(friend_number);
		}



		public uint32[] get_friend_list(){
			uint32[] retval = new uint32[internal_handle.self_get_friend_list_size()];
			internal_handle.self_get_friend_list(retval);
			return retval;
		}


	}
	
	
	
		
 	
 	
 	private string arr2str(uint8[] array){
		uint8[] name = new uint8[array.length + 1];
		GLib.Memory.copy(name, array, sizeof(uint8)* name.length);
		name[array.length] = '\0';
		return ((string) name).to_string();
	}
 
 }
