/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* tox-session.c
 * tox-session.vala
 * This file is part of Venom
 * Copyright (C) 2015 Venom authors
 * Venom is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Venom is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 using ToxCore;
 
 public class Options: ToxCore.Options{
 	public Options(){
			TOX_ERR_OPTIONS_NEW en;
			Options ret = ToxCore.Options.options_new(out en);
			return ret;
		}
 }
 
 public class Tox{
 	/**
	 * The major version number. Incremented when the API or ABI changes in an
	 * incompatible way.
	 */
	public const uint32 MAJOR = ToxCore.Version.MAJOR;
			/**
	 * The minor version number. Incremented when functionality is added without
	 * breaking the API or ABI. Set to 0 when the major version number is
	 * incremented.
	 */
	public const uint32 MINOR = ToxCore.Version.MINOR;
	/**
	 * The patch or revision number. Incremented when bugfixes are applied without
	 * changing any functionality or API or ABI.
	 */
	public const uint32 PATCH = ToxCore.Version.PATCH;

	/**
	 * A macro to check at preprocessing time whether the client code is compatible
	 * with the installed version of Tox.
	 */
	
	public static bool is_api_compatible(uint32 major, uint32 minor, uint32 patch){
		return ToxCore.Version.is_api_compatible(major,minor,patch);
	}
	/**
	 * A macro to make compilation fail if the client code is not compatible with
	 * the installed version of Tox.
	 */
	public static char require_version(uint32 major, uint32 minor, uint32 patch){
		return ToxCore.Version.require_version(major, minor, patch);
	}

	/**	
	 * Return the major version number of the library. Can be used to display the
	 * Tox library version or to check whether the client is compatible with the
	 * dynamically linked version of Tox.
	 */	
	
	public static uint32 library_major(){
		return ToxCore.Version.library_major();
	}

	/**
	 * Return the minor version number of the library.
	 */
	
	public static uint32 library_minor(){
		return ToxCore.Version.library_minor();
	}
	
	/**
	 * Return the patch number of the library.
	 */
	public static uint32 library_patch(){
		return ToxCore.Version.library_patch();
	}
	/**
	 * Return whether the compiled library version is compatible with the passed
	 * version numbers.
	 */

	public static bool is_compatible(uint32 major, uint32 minor, uint32 patch){
		return ToxCore.Version.is_compatible(major,minor,patch);
	}
	/**
	 * A convenience macro to call tox_version_is_compatible with the currently
	 * compiling API version.
	 */
	public static bool is_abi_compatible(){
		return ToxCore.Version.is_abi_compatible();
	}
	
	

	/**
	 * The size of a Tox Public Key in bytes.
	 */
	public const int PUBLIC_KEY_SIZE = ToxCore.Version.PUBLIC_KEY_SIZE;

	/**
	 * The size of a Tox Secret Key in bytes.
	 */
	public const int SECRET_KEY_SIZE = ToxCore.Version.SECRET_KEY_SIZE;

	/**
	 * The size of a Tox address in bytes. Tox addresses are in the format
	 * [Public Key (TOX_PUBLIC_KEY_SIZE bytes)][nospam (4 bytes)][checksum (2 bytes)].
	 *
	 * The checksum is computed over the Public Key and the nospam value. The first
	 * byte is an XOR of all the even bytes (0, 2, 4, ...), the second byte is an
	 * XOR of all the odd bytes (1, 3, 5, ...) of the Public Key and nospam.
	 */
	public const int ADDRESS_SIZE = ToxCore.Version.ADDRESS_SIZE;
	/**
	 * Maximum length of a nickname in bytes.
	 */
	public const int MAX_NAME_LENGTH = ToxCore.Version.MAX_NAME_LENGTH;
  
	/**
	 * Maximum length of a status message in bytes.
	 */
	public const int MAX_STATUS_MESSAGE_LENGTH = ToxCore.Version.MAX_STATUS_MESSAGE_LENGTH;

	/**
	 * Maximum length of a friend request message in bytes.
	 */
	public const int MAX_FRIEND_REQUEST_LENGTH = ToxCore.Version.MAX_FRIEND_REQUEST_LENGTH;
	
	/**
	 * Maximum length of a single message after which it should be split.
	 */
	public const int MAX_MESSAGE_LENGTH = ToxCore.Version.MAX_MESSAGE_LENGTH;
	/**
	 * Maximum size of custom packets. TODO: should be LENGTH?
	 */
	public const int MAX_CUSTOM_PACKET_SIZE = ToxCore.Version.MAX_CUSTOM_PACKET_SIZE;

	/**
	 * The number of bytes in a hash generated by tox_hash.
	 */
	public const int HASH_LENGTH = ToxCore.Version.HASH_LENGTH;
	/**
	 * The number of bytes in a file id.
	 */
	public const int FILE_ID_LENGTH = ToxCore.Version.FILE_ID_LENGTH;

	/**
	 * Maximum file name length for file transfers.
	 */
	public const int MAX_FILENAME_LENGTH = ToxCore.Version.MAX_FILENAME_LENGTH;
	
	
	public errordomain BootstrapError{
		BAD_HOST,
		BAD_PORT,
	}
		
	public errordomain FriendAddError {
		TOOLONG,
		NO_MESSAGE,
		OWN_KEY,
		ALREADY_SENT,
		UNKNOWN,
		BAD_CHECKSUM,
		SET_NEW_NOSPAM,
		NOMEM,
	}		
	
	public errordomain FriendGetError{
		NOT_FOUND,
		UNKNOWN,		
	}
		
	public errordomain SendMessageError{
	
		/**
		 * The friend number did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,

		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,

		/**
		 * An allocation error occurred while increasing the send queue size.
		 */
		SENDQ,


	}
	
	public errordomain FileControlError{
		/**
		 * The friend_number passed did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,
		
		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,
		
		/**
		 * No file transfer with the given file number was found for the given friend.
		 */
		NOT_FOUND,
		
		/**
		 * A RESUME control was sent, but the file transfer is running normally.
		 */
		NOT_PAUSED,
	
		/**
		 * A RESUME control was sent, but the file transfer was paused by the other
		 * party. Only the party that paused the transfer can resume it.
		 */
		DENIED,
		
		/**
		 * A PAUSE control was sent, but the file transfer was already paused.
		 */
		ALREADY_PAUSED,
		
		/**
		 * Packet queue is full.
		 */
		SENDQ,
	
	}
	
	public errordomain FileSeekError {
		
		/**
		 * The friend_number passed did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,
		
		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,
		
		/**
		 * No file transfer with the given file number was found for the given friend.
		 */
		NOT_FOUND,
		
		/**
		 * File was not in a state where it could be seeked.
		 */
		DENIED,
		
		/**
		 * Seek position was invalid
		 */
		INVALID_POSITION,
		
		/**
		 * Packet queue is full.
		 */
		SENDQ,

	}
	
	public errordomain FileGetError{
		/**
	     * The friend_number passed did not designate a valid friend.
	     */
	    FRIEND_NOT_FOUND,

	    /**
	     * No file transfer with the given file number was found for the given friend.
	     */
    	NOT_FOUND,
	
	}
	
	public errordomain FileSendError{
		FRIEND_NOT_FOUND,
		FRIEND_NOT_CONNECTED,
		TOO_MANY,
	}
	
	public errordomain FileSendChunkError{
		FRIEND_NOT_FOUND,
		FRIEND_NOT_CONNECTED,
		NOT_FOUND,
		NOT_TRANSFERRING,
		INVALID_LENGTH,
		SENDQ,
		WRONG_POSITION,
	}
  	
  	public errordomain CustomPacketError{
  		/**
		 * The friend number did not designate a valid friend.
		 */
		FRIEND_NOT_FOUND,
		/**
		 * This client is currently not connected to the friend.
		 */
		FRIEND_NOT_CONNECTED,
		/**
		 * The first byte of data was not in the specified range for the packet type.
		 * This range is 200-254 for lossy, and 160-191 for lossless packets.
		 */
		INVALID,
		/**
		 * Packet data length exceeded TOX_MAX_CUSTOM_PACKET_SIZE.
		 */
		TOO_LONG,
		/**
		 * Packet queue is full.
		 */
		SENDQ,
  	
  	}
	
	
	
	
	
	private ToxCore.ToxRaw? handle;
	
		
 	
 	
 	private string arr2str(uint8[] array){
		uint8[] name = new uint8[array.length + 1];
		GLib.Memory.copy(name, array, sizeof(uint8)* name.length);
		name[array.length] = '\0';
		return ((string) name).to_string();
	}
 
 }
